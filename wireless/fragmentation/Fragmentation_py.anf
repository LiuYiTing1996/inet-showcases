<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<analysis version="2">
    <inputs>
        <input pattern="/inet/showcases/wireless/fragmentation/results/DCFnofrag*.*"/>
        <input pattern="/inet/showcases/wireless/fragmentation/results/DCFfrag-#*.*"/>
        <input pattern="/inet/showcases/wireless/fragmentation/results/HCFfrag-#*.*"/>
        <input pattern="/inet/showcases/wireless/fragmentation/results/HCFfragblockack-#*.*"/>
        <input pattern="/inet/showcases/wireless/fragmentation/results/OnlyPacketSize*.vec"/>
        <input pattern="/inet/showcases/wireless/fragmentation/results/OnlyPacketSize*.sca"/>
        <input pattern="/inet/showcases/wireless/fragmentation/results/Threshold*.vec"/>
        <input pattern="/inet/showcases/wireless/fragmentation/results/Threshold*.sca"/>
        <input pattern="/inet/showcases/wireless/fragmentation/results/PacketSize*.vec"/>
        <input pattern="/inet/showcases/wireless/fragmentation/results/PacketSize*.sca"/>
        <input pattern="/inet/showcases/wireless/fragmentation/results/TxPower*.vec"/>
        <input pattern="/inet/showcases/wireless/fragmentation/results/TxPower*.sca"/>
    </inputs>
    <charts>
        <chart name="Throughput" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import chart&#10;&#10;import operations as ops&#10;&#10;# This expression selects the results (you might be able to logically simplify it)&#10;filter_expression = &quot;&quot;&quot;&#10;ADD vectors WHERE attr:experiment(DCFfrag) AND attr:replication(#0) AND module(FragmentationShowcase.wifiHost2.app[0]) AND name(throughput:vector)&#10;ADD vectors WHERE attr:experiment(DCFnofrag) AND attr:replication(#0) AND module(FragmentationShowcase.wifiHost2.app[0]) AND name(throughput:vector)&#10;ADD vectors WHERE attr:experiment(HCFfrag) AND attr:replication(#0) AND module(FragmentationShowcase.wifiHost2.app[0]) AND name(throughput:vector)&#10;ADD vectors WHERE attr:experiment(HCFfragblockack) AND attr:replication(#0) AND module(FragmentationShowcase.wifiHost2.app[0]) AND name(throughput:vector)&#10;&quot;&quot;&quot;&#10;&#10;# The data is returned as a Pandas DataFrame&#10;df = results.getVectors(filter_expression)&#10;&#10;# Which we turn into a more usable format&#10;df = results.transform_results(df)&#10;&#10;# You can perform any transformations on the data here&#10;&#10;df.result['vecvalue'] /= 1000000&#10;&#10;print(df.index.get_level_values('experiment'))&#10;&#10;names = list(df.index.get_level_values('experiment'))&#10;&#10;print(names)&#10;&#10;df[('attr','title')] = names&#10;&#10;# Finally, the results are plotted&#10;chart.plotVectors(df)&#10;" type="LineChart">
            <property name="Graph.Title" value="Throughput"/>
            <property name="X.Axis.Title" value="Time [s]"/>
            <property name="Y.Axis.Title" value="Throughput [Mbps]"/>
        </chart>
        <chart name="Number of packets received" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import chart&#10;from results import pivotScalars&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.wifiHost2.app[0]) AND name(&quot;packetReceived:count&quot;)))&quot;&quot;&quot;&#10;&#10;df = results.getScalars(filter_string)&#10;&#10;df = results.pivotScalars(df, columns=[&quot;module&quot;], index=[&quot;configname&quot;])&#10;&#10;print(df)&#10;&#10;print(&quot;--------------------------&quot;)&#10;&#10;df = df.reindex([&quot;DCFnofrag&quot;,&quot;DCFfrag&quot;,&quot;HCFfrag&quot;,&quot;HCFfragblockack&quot;])&#10;&#10;chart.plotScalars(df)&#10;&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;" type="BarChart">
            <property name="Graph.Title" value="Number of packets received"/>
        </chart>
        <chart name="Throughput vs packet size (fixed 250B frag threshold)" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import chart&#10;import numpy as np&#10;import pandas as pd&#10;&#10;import operations as ops&#10;&#10;# This expression selects the results (you might be able to logically simplify it)&#10;filter_expression = &quot;&quot;&quot;&#10;ADD vectors WHERE attr:experiment(OnlyPacketSize*) AND attr:replication(#0) AND module(FragmentationShowcase.wifiHost2.app[0]) AND name(throughput:vector)&#10;&quot;&quot;&quot;&#10;&#10;# The data is returned as a Pandas DataFrame&#10;df = results.getVectors(filter_expression)&#10;&#10;# Which we turn into a more usable format&#10;# df = results.transform_results(df)&#10;&#10;df = results.transform_results(df)&#10;&#10;# print(df)&#10;&#10;&#10;# replace vecvalues with their averages&#10;df[(&quot;result&quot;,&quot;vecvalue&quot;)] = df[(&quot;result&quot;,&quot;vecvalue&quot;)].apply(np.mean)&#10;&#10;# make index columns into regular columns (index becomes a single integer series)&#10;df.reset_index(inplace=True)&#10;&#10;# filter the columns of interest (discard the rest)&#10;df = df[[('experiment', ''), ('result', 'vecvalue'), ('itervar', 'packetSize')]]&#10;&#10;# rename column headers so its single level (and more meaningful)&#10;df.columns = [&quot;experiment&quot;, &quot;Throughput&quot;, &quot;packetSize&quot;]&#10;&#10;# pivot the data so the experiment labels become column headers and packet sizes become index values&#10;df = pd.pivot_table(df, columns=&quot;experiment&quot;, index=&quot;packetSize&quot;)&#10;&#10;# convert index to numeric...&#10;df.index = pd.to_numeric(df.index)&#10;&#10;# so we can sort it by numeric value&#10;df.sort_index(inplace=True)&#10;&#10;print(df)&#10;&#10;# You can perform any transformations on the data here&#10;&#10;# finally we plot each line individually by iterating on the columns (experiments)&#10;for column in df:&#10;    numbers = np.isfinite(df[column])   # create a boolean mask to indicate where we have actual values (non NaN's)&#10;    chart.plotVector(column[1][len(&quot;OnlyPacketSize&quot;):], # remove common prefix from column header&#10;                     df.index.values[numbers], # filter the index using the mask&#10;                     df[column][numbers] / 1024 / 1024) # filter the values and convert to Mbps&#10;&#10;" type="LineChart">
            <property name="Graph.Title" value="Throughput vs packet size (fixed 250B frag threshold)"/>
        </chart>
        <chart name="Throughput vs fragmentation threshold" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import chart&#10;import numpy as np&#10;import pandas as pd&#10;&#10;import operations as ops&#10;&#10;# This expression selects the results (you might be able to logically simplify it)&#10;filter_expression = &quot;&quot;&quot;&#10;ADD vectors WHERE attr:experiment(Threshold*) AND attr:replication(#0) AND module(FragmentationShowcase.wifiHost2.app[0]) AND name(throughput:vector)&#10;&quot;&quot;&quot;&#10;&#10;# The data is returned as a Pandas DataFrame&#10;df = results.getVectors(filter_expression)&#10;&#10;# Which we turn into a more usable format&#10;# df = results.transform_results(df)&#10;&#10;df = results.transform_results(df)&#10;&#10;# print(df)&#10;&#10;&#10;# replace vecvalues with their averages&#10;df[(&quot;result&quot;,&quot;vecvalue&quot;)] = df[(&quot;result&quot;,&quot;vecvalue&quot;)].apply(np.mean)&#10;&#10;# make index columns into regular columns (index becomes a single integer series)&#10;df.reset_index(inplace=True)&#10;&#10;# filter the columns of interest (discard the rest)&#10;df = df[[('experiment', ''), ('result', 'vecvalue'), ('itervar', 'threshold')]]&#10;&#10;# rename column headers so its single level (and more meaningful)&#10;df.columns = [&quot;experiment&quot;, &quot;Throughput&quot;, &quot;threshold&quot;]&#10;&#10;# pivot the data so the experiment labels become column headers and packet sizes become index values&#10;df = pd.pivot_table(df, columns=&quot;experiment&quot;, index=&quot;threshold&quot;)&#10;&#10;# convert index to numeric...&#10;df.index = pd.to_numeric(df.index)&#10;&#10;# so we can sort it by numeric value&#10;df.sort_index(inplace=True)&#10;&#10;print(df)&#10;&#10;# You can perform any transformations on the data here&#10;&#10;# finally we plot each line individually by iterating on the columns (experiments)&#10;for column in df:&#10;    numbers = np.isfinite(df[column])   # create a boolean mask to indicate where we have actual values (non NaN's)&#10;    chart.plotVector(column[1][len(&quot;Threshold&quot;):], # remove common prefix from column header&#10;                     df.index.values[numbers], # filter the index using the mask&#10;                     df[column][numbers] / 1024 / 1024) # filter the values and convert to Mbps&#10;&#10;" type="LineChart">
            <property name="Graph.Title" value="Throughput vs fragmentation threshold"/>
        </chart>
        <chart name="Throughput vs packet size (variable frag threshold)" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import chart&#10;import numpy as np&#10;import pandas as pd&#10;&#10;import operations as ops&#10;&#10;# This expression selects the results (you might be able to logically simplify it)&#10;filter_expression = &quot;&quot;&quot;&#10;ADD vectors WHERE attr:experiment(PacketSize*) AND attr:replication(#0) AND module(FragmentationShowcase.wifiHost2.app[0]) AND name(throughput:vector)&#10;&quot;&quot;&quot;&#10;&#10;# The data is returned as a Pandas DataFrame&#10;df = results.getVectors(filter_expression)&#10;&#10;# Which we turn into a more usable format&#10;# df = results.transform_results(df)&#10;&#10;df = results.transform_results(df)&#10;&#10;# print(df)&#10;&#10;&#10;# replace vecvalues with their averages&#10;df[(&quot;result&quot;,&quot;vecvalue&quot;)] = df[(&quot;result&quot;,&quot;vecvalue&quot;)].apply(np.mean)&#10;&#10;# make index columns into regular columns (index becomes a single integer series)&#10;df.reset_index(inplace=True)&#10;&#10;# filter the columns of interest (discard the rest)&#10;df = df[[('experiment', ''), ('result', 'vecvalue'), ('itervar', 'packetSize')]]&#10;&#10;# rename column headers so its single level (and more meaningful)&#10;df.columns = [&quot;experiment&quot;, &quot;Throughput&quot;, &quot;packetSize&quot;]&#10;&#10;# pivot the data so the experiment labels become column headers and packet sizes become index values&#10;df = pd.pivot_table(df, columns=&quot;experiment&quot;, index=&quot;packetSize&quot;)&#10;&#10;# convert index to numeric...&#10;df.index = pd.to_numeric(df.index)&#10;&#10;# so we can sort it by numeric value&#10;df.sort_index(inplace=True)&#10;&#10;print(df)&#10;&#10;# You can perform any transformations on the data here&#10;&#10;# finally we plot each line individually by iterating on the columns (experiments)&#10;for column in df:&#10;    numbers = np.isfinite(df[column])   # create a boolean mask to indicate where we have actual values (non NaN's)&#10;    chart.plotVector(column[1][len(&quot;PacketSize&quot;):], # remove common prefix from column header&#10;                     df.index.values[numbers], # filter the index using the mask&#10;                     df[column][numbers] / 1024 / 1024) # filter the values and convert to Mbps&#10;&#10;" type="LineChart">
            <property name="Graph.Title" value="Throughput vs packet size (variable frag threshold)"/>
        </chart>
        <chart name="Throughput vs SNIR" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import chart&#10;import numpy as np&#10;import pandas as pd&#10;&#10;import operations as ops&#10;&#10;&#10;pd.set_option(&quot;display.width&quot;,1000000)&#10;pd.set_option(&quot;display.max_columns&quot;,None)&#10;&#10;&#10;# there are two implementations, switch between them with True and False here&#10;if True:&#10;    # this should be readily available in results, in a more optimized form&#10;    # can be used to query any kind of results (even mixed), with a single&#10;    # filter expression, returned already in &quot;transformed&quot; form&#10;    def getResults(filter):&#10;        df = pd.DataFrame()&#10;        &#10;        df = df.append(results.transform_results(results.getVectors(filter)))&#10;        df = df.append(results.transform_results(results.getScalars(filter)))&#10;        &#10;        return df&#10;    &#10;    # query the vector and scalar results together&#10;    df = getResults(&quot;&quot;&quot;&#10;    (attr:experiment(TxPower*) AND attr:replication(#0) AND module(FragmentationShowcase.wifiHost2.app[0]) AND name(throughput:vector))&#10;    OR&#10;    (attr:experiment(TxPower*) AND attr:replication(#0) AND module(FragmentationShowcase.wifiHost2.*) AND name(minSnir:histogram:mean))&#10;    &quot;&quot;&quot;)&#10;    &#10;    # merge the scalars and the mean of the vectors into a new column&#10;    df['value_or_mean'] = df.apply(lambda r:&#10;                                r[('result', 'value')]&#10;                                if np.isfinite(r[('result', 'value')])&#10;                                else np.mean(r[('result', 'vecvalue')]),&#10;                            axis=1)&#10;    &#10;    # pivot, so he experiment and result names become column headers&#10;    df = pd.pivot_table(df[[&quot;value_or_mean&quot;]], columns=[&quot;experiment&quot;, &quot;name&quot;], index=&quot;measurement&quot;)&#10;    &#10;    # get rid of the two extra column header levels we don't need, introduced by pivot_table&#10;    df.columns = df.columns.droplevel().droplevel()&#10;    &#10;    # finally we plot each line individually by iterating on the columns (experiments)&#10;    for column in df.columns.unique(0):&#10;        chart.plotVector(column[len('TxPower'):],&#10;                         df[column]['minSnir:histogram:mean'], # filter the index using the mask&#10;                         df[column]['throughput:vector']/1e6) # filter the values and convert to Mbps&#10;&#10;else:    &#10;    # The data is returned as a Pandas DataFrame&#10;    df1 = results.getVectors(&quot;attr:experiment(TxPower*) AND attr:replication(#0) AND module(FragmentationShowcase.wifiHost2.app[0]) AND name(throughput:vector)&quot;)&#10;    df1 = results.transform_results(df1)&#10;    &#10;    df1[(&quot;result&quot;,&quot;value&quot;)] = df1[(&quot;result&quot;,&quot;vecvalue&quot;)].apply(np.mean)&#10;    df1 = df1[[('result', 'value')]]&#10;    &#10;    df1.reset_index(level=[&quot;name&quot;, &quot;module&quot;], drop=True, inplace=True)&#10;    df1.columns= [&quot;throughput&quot;]&#10;    &#10;    &#10;    df2 = results.getScalars(&quot;attr:experiment(TxPower*) AND attr:replication(#0) AND module(FragmentationShowcase.wifiHost2.*) AND name(minSnir:histogram:mean)&quot;)&#10;    df2 = results.transform_results(df2)&#10;    &#10;    df2 = df2[[('result', 'value')]]&#10;    df2.reset_index(level=[&quot;name&quot;, &quot;module&quot;], drop=True, inplace=True)&#10;    df2.columns= [&quot;SNIR&quot;]&#10;    &#10;    #print(df2)&#10;    &#10;    df = pd.concat([df1, df2], axis=1)&#10;    &#10;    # make index columns into regular columns (index becomes a single integer series)&#10;    df.reset_index(inplace=True)&#10;    &#10;    # print(df)&#10;    &#10;    # pivot the data so the experiment labels become column headers and packet sizes become index values&#10;    df = pd.pivot_table(df, columns=&quot;experiment&quot;, index=&quot;measurement&quot;)&#10;    &#10;    df = df.swaplevel(axis=1)&#10;    df.sort_index(axis=1, inplace=True)&#10;    # print(df)&#10;    &#10;    # You can perform any transformations on the data here&#10;    &#10;    # finally we plot each line individually by iterating on the columns (experiments)&#10;    for column in df.columns.unique(0):&#10;        chart.plotVector(column[len('TxPower'):],&#10;                         df[column]['SNIR'], # filter the index using the mask&#10;                         df[column]['throughput']/1e6) # filter the values and convert to Mbps&#10;    &#10;&#10;" type="LineChart">
            <property name="Graph.Title" value="Throughput vs SNIR"/>
        </chart>
    </charts>
</analysis>
